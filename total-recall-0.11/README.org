# :ID: 2b6a2d42-bfd0-4658-b25a-b1b7000d1b01

* Preliminaries

This file is meant to be viewed using Emacs and Org Mode.

* Introduction

~total-recall~ is an interactive function that provides spaced repetition for Emacs. It
manages "elements" (i.e., definitions and exercises) stored in Org files under
~total-recall-root-dir~.

Elements are sorted based on dependencies (e.g., if element A requires element B,
element B is presented first). If circular dependencies are detected, they are
eliminated as a fallback mechanism and the cycles are presented to be manually
removed. Element selection uses historical data to optimize review frequency: easier
elements are shown less often.

Given that type values are configurable, a definition has the
form:

#+begin_src org
,* Name
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: e0d2d8ee-0371-4f92-93e5-6b2231871c90
:END:

Content.
#+end_src

An exercise has the form:

#+begin_src org
,* Name
:PROPERTIES:
:TYPE: b0d53cd4-ad89-4333-9ef1-4d9e0995a4d8
:ID: 6296bdc8-7d5a-4191-81d4-f5b8a4c282b4
:END:

,** Question

Content. The name of the headline is arbitrary.

,** Answer

Content. The name of the headline is arbitrary.
#+end_src

* TODO Installation

MELPA

* TODO Usage

* Specification

This section specifies the program. Python code provides interfaces used for
quantitative computations /e.g./ ordering and selecting elements. Emacs Lisp code
provides everything else /e.g./ the UI.

« Objects » are specified in =specify= sections while candidate implementations are
provided in =build= sections. Other sections like =discuss=, =test= or =prove= are
self-explanatory.

** Emacs Lisp
*** Utils
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       a8b1ee2d-6a1a-441e-a3f0-7681f9091032
:END:
**** specify

Utils is a set of macros and functions.

***** reduce-while

Step :≡ Any → 'cont × Any | 'halt × Any

Steps :≡ List(Step)

reduce-while : Any Steps → Any :≡
- λacc,steps.↓
  - match steps
    - [] → acc
    - [step | steps] →
      - match step(acc)
        - <'halt, acc> → acc
        - <'cont, acc> → reduce-while(acc steps)

***** satisfies-invariant-p

satisfies-invariant-p : Any Keyword → Boolean :≡
- λany,kw.↓
  - if any is not a function, return false
  - try
    - return kw ∈ any('invariants) # TODO: find a better way.
  - catch
    - return false

***** nat-p : Any → Boolean
***** epoch-p : Any → Boolean
***** epoch→iso8601 : Epoch → ISO8601
***** iso8601→epoch : ISO8601 → Epoch
***** probability-p : Any → Boolean
***** list-of-p : Any (Any → Boolean) → Boolean
***** send

Actor :≡ Any → Any

Message :≡ Any

send : Actor Message → Any :≡ λactor,msg.actor msg

***** pp

pp : Any → ∅

After pp(any), any has been printed in a buffer and the buffer has been displayed.

***** context

context : List(Symbol) Body → Form

context is a macro that avoids the need to prefix names with =total-recall--=.

#+begin_src emacs-lisp
(total-recall--context (f) body)
#+end_src

Is expanded to:

#+begin_src emacs-lisp
(cl-flet ((f #'total-recall--f)) body)
#+end_src

***** wait-until-process-run

Process :≡ [[info:elisp#Processes][elisp#Processes]]

Timeout :≡ Second

Delta :≡ Second

wait-until-process-run : Process Timeout Delta → Nil

wait-until-process-run(process timeout delta) blocks for delta until process is in
state 'run. When timeout is exhausted, raise an error.

***** uuid-p : Any → Boolean
***** uuid-re : RegEx
***** uuid-re-strict : RegEx

*** Env
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:
**** specify

Env :≡ "prod" | "dev" | "test"

*** Logger
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 065a3037-8cb1-44f3-8070-7c5b3c96015b
:END:
**** specify

Logger#mk : Env → Logger

logger :≡ Logger#mk env

logger#debug : String → Nil

logger#info : String → Nil

logger#error : String → Nil

∀ name, logger#name(msg) prints =msg= to stdout according to =env=. If env = "prod", then
only prints errors. If env = "test", then only prints errors. If env = "dev", then
print all messages.

*** Actor
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:
**** specify

Actor#mk : Logger … → Actor

actor :≡ Actor#mk logger …

send(actor msg) : Any

send(actor msg) → logger#debug(msg)

*** Clock
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       d9892346-2b6b-4ceb-9da9-00de63d5e6ee
:END:
**** specify

Clock#mk : Logger → Clock

clock :≡ Clock#mk logger

clock is an Actor.

now : Epoch :≡ clock#now(). now is the time at call time.

*** Io
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: a5fdf3d6-a742-418f-9af6-8e83cf2bcef6
:END:
**** specify

Io#mk : Logger String → Io

io :≡ Io#mk logger name

io is an Actor

io#minibuffer : String → Io
io#minibuffer(msg) writes the msg to the minibuffer and returns self

io#buffer : String → Io
io#buffer(msg) writes the msg to the buffer named after ~name~ and returns self

io#buffer-name() = name of the associated buffer built from input name

*** Report
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 05a4ce8c-583a-43d2-9dde-af32164d1a97
:END:
**** specify

Report#mk : Logger → Report

report :≡ Report#mk logger

report is an Actor

report#add : String → Report
report#add(line) adds line to the accumulated lines so far

report#string() : String :≡ the concatenation of all accumulated lines.

*** Conf
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 656ec911-0225-415d-abf0-4e760bc782f1
:END:
**** specify

Configuration#mk() : Configuration

conf :≡ Configuration#mk()

∀ name as defined in the interface, of the conf#name() gives the associated value.

All values are derived from the environment.

*** Rating
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 168a29cc-9c72-4e31-b619-8a8cb5b37c0a
:END:
**** specify

Value :≡ :success | :failure | :skip

Rating#mk : Epoch UUID Value → Rating

Rating#p : Any → Boolean

Rating#success :≡ λepoch,uuid.Rating#mk epoch uuid :success

Rating#failure :≡ λepoch,uuid.Rating#mk epoch uuid :failure

Rating#skip :≡ λepoch,uuid.Rating#mk epoch uuid :skip

rating :≡ Rating#mk(epoch id value)

rating#data() :≡ [epoch, id, value]

*** Exercise
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       d6b90764-fff1-4bd6-909a-322912b0da73
:END:
**** specify

Name :≡ List(String)

Id :≡ UUID

Question :≡ String

Answer :≡ String

Exercise#mk : Path Id Name Question Answer → Exercise

exercise :≡ Exercise#mk path id name question answer

exercise#file() = path

exercise#id() = id

exercise#path() = name

exercise#question() = question

exercise#answer() = answer

*** Definition
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       64dc5603-95db-44fd-a37a-46ad390be8e7
:END:
**** specify

Name :≡ List(String)

Id :≡ UUID

Content :≡ String

Definition#mk : Path Id Name Content → Definition

definition :≡ Definition#mk path id name content

definition#file() = path

definition#id() = id

definition#path() = name

definition#content() = content

*** Searcher
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 397d808c-4438-45fa-9ff6-3db404e99dd2
:END:
**** specify

Root :≡ Path to a directory where search occurs

DefUUID :≡ UUID that identifies a definition (value of the :TYPE: drawer property).

ExUUID :≡ UUID that identifies an exercise (value of the :TYPE: drawer property).

Ripgrep :≡ Absolute path to ripgrep or name of the PATH executable

Searcher#mk : Logger Root DefUUID ExUUID Ripgrep → Searcher

searcher :≡ Searcher#mk logger root defid exid rg

search is an Actor

searcher#files() : List(Path) :≡ list of absolute org file paths under root that
contain at least one occurrence of defid or exid.

*** Parser
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 5c51b191-f640-434a-a194-a432ee2e967f
:END:
**** specify

ExType :≡ Strings that identify exercises types.

DefType :≡ Strings that identify exercises types.

Parser#mk : [[ref:0bd721c4-cef2-4cf5-9bfe-5ae3ae548cce][Logger]] ExType DefType → Parser

parser ≡ Parser#mk logger ex-type def-type

parser is an Actor

parser#parse : OrgFile → List([[ref:d6b90764-fff1-4bd6-909a-322912b0da73][Exercise]])

parser#parse : List(OrgFile) → List([[ref:d6b90764-fff1-4bd6-909a-322912b0da73][Exercise]]) :≡ λfiles.map-concat parser#parse files

**** build
***** Headline → 'ok × ExData | 'error × String

[[file:dot/parser.dot]]

*** Selector
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       1ce846c7-9f47-4cdb-91bf-5a68cc6ef6f2
:END:
**** specify

Venv :≡ Path to the directory where the python venv is to be installed.

Lib :≡ Path to the directory where Python source code is stored.

Selector#mk : Logger Clock Venv Lib Db → Selector

selector : Selector

selector is an Actor

selector#select : List(UUID) → List(UUID)

selected :≡ selector#select uuids

selected properties are derived from the underlying server.

*** Graph
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       c5b46e6f-1cad-4aed-9ff6-d299074eac58
:END:
**** specify

Venv :≡ Path to the directory where the python venv is to be installed.

Lib :≡ Path to the directory where Python source code is stored.

Graph#mk : Logger Venv Lib → Graph

graph :≡ Graph#mk Logger Venv Lib

graph is an Actor

Nodes :≡ List(UUID)

Edges :≡ List(UUID × UUID)

graph#sort : Nodes Edges → 'ok × Nodes | 'error × String

<'ok, sorted-nodes> :≡ graph#sort nodes edges

sorted-nodes properties are derived from the underlying server.

*** Scheduler
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       f7e13fe3-4ff0-4ebc-8dcc-78c6e8df3516
:END:
**** specify

Scheduler#mk : Logger Graph Selector → Scheduler

scheduler :≡ Scheduler#mk logger graph selector

scheduler#schedule : List(Exercise) Threshold Time → List(Exercise)

exercises :≡ schedule#schedule exs thr time

exercises is a sub-list of exs, each one selected by ~selector~ and ordered using ~graph~.

**** build

[[file:dot/scheduler.dot]]

*** Db
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       74d00768-f37a-49c9-a943-4a39f1a26c0e
:END:
**** specify

DBPath :≡ Path to a regular file that represents a sqlite3 database | Nil

DB#mk : Logger DBPath → DB

db :≡ DB#mk logger db-path

db#stop() : Self

db#save : Rating → Self

db#ratings : UUID → List(Rating)

*** Ui
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       2e317042-46f4-4407-9bd4-68ec22c1955e
:END:
**** specify

Name :≡ Strings used as the base name for the buffer where the review will occur

Width, Height :≡ Nat that specifies the respective dimensions of the frame

Success, Failure, Quit, Skip, Reveal : Characters used as keys for the relevant buttons

Ui#mk : Logger Name Width Height Success Failure Skip Reveal → Ui

ui :≡ Ui#mk

ui is an Actor

ui#show : Exercise UserInputs → 'stop | 'skip | 'success | 'failure

*** Reviewer
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 088be4f0-e515-4501-b6f7-28201d1d0713
:END:
**** specify

Reviewer#mk : Logger Db Ui List([[ref:d6b90764-fff1-4bd6-909a-322912b0da73][Exercise]]) → Reviewer

reviewer ≡ Reviewer#mk logger db ui exercises

reviewer is an Actor

reviewer#start : UserInputs → [[ref:05a4ce8c-583a-43d2-9dde-af32164d1a97][Report]]

*** total-recall
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       9030fde9-f7fc-4c83-a54b-41fd1a9872d7
:END:
**** TODO specify

total-recall is an interactive function. After execution, the user has completed a
review session, meaning:
1.
1. All [[ref:2ade1c31-ced1-4673-a7f2-b63b7a20ab26][exercises]] in the file system under [[ref:5709bbc0-e7e6-4eba-90c9-1840b010f3b2][root-dir]] have been
   [[ref:76f234fc-5f51-4626-80a5-23e8dfcc50e2][scheduled]] and reviewed or skipped through the [[ref:7c752724-7e3d-4529-bf1b-06482ca53b3e][ui]].
2. Review data have been recorded in a [[ref:f55fac90-c922-4653-bfb0-10f83a68d53c][database]] under [[ref:7a2f9b87-a2f8-4fd1-991c-deab4100614c][db-path]].
3. The user has been informed of their performance by a [[ref:4187a5b0-15c1-49fc-9962-7dd5802e4f25][report]] written to the [[ref:2076d556-ee35-4db7-bd58-887bc5a1c254][io]] of
   Emacs.

*** package
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       882edf25-44bc-4308-bfef-10ce2f8acd00
:END:
**** specify

package : [[info:elisp#Multi-file Packages][elisp#Multi-file Packages]]

** Python
*** Configuration
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: dd62b36a-0c72-4e49-bef9-f02feec16ac4
:END:
**** specify

Configuration#mk() : Configuration

conf :≡ Configuration#mk()

conf#venv_path() : Path :≡ the path where the venv is installed as specified by the
user.

After conf, Python executes in UTF-8 mode and the environment is read.

*** Mark
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: c561f394-58e8-48a9-a2fe-0ce8bbbc73ad
:END:
**** specify

Mark#success() : Mark

Mark#failure() : Mark

Mark#skip() : Mark

Mark#from_string : String → Mark :≡ λs.↓
- match s
  - ":success" → Mark#success()
  - ":failure" → Mark#failure()
  - ":skip" → Mark#skip()

Mark#string : Mark → String

Mark#from_string(Mark#string(m)) = m

*** Time
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 00d5252c-a7d7-4ba5-82a7-7cc7df315994
:END:
**** specify

Time#mk : ISO8601UTC → Time

time :≡ Time#mk s where s is an ISO8601 UTC string

time#string() : String :≡ s

*** Identifier
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: c739cc33-3efc-43bd-9c2c-6bb13af09720
:END:
**** specify

Identifier#mk : String → Identifier :≡ λs.↓
- if s is a UUID hex string, return Identifier#mk(s)

Identifier#= : Identifier Identifier → Boolean

∀ id1 id2, id1 = id2 iff Identifier#=(id1 id2)

identifier :≡ Identifier#mk(s)

identifier#string() : String :≡ s

*** JsonProtocol
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: a9530b61-915e-4e0f-8fac-077b12a7399e
:END:
**** specify

JsonProtocol#string : Any → String :≡ λx.x#json_string()

*** Error
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: d1ff1c40-a6e6-4054-afbe-71fb2b77eba2
:END:
**** specify

Error#mk : Any → Error :≡ λany.↓
- if any implements JsonProtocol, return Error#mk(any)

Instances of Error implement JsonProtocol.

*** Ok
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 2a4529d8-85b7-4b74-928f-fc1506800855
:END:
**** specify

Ok#mk : Any → Ok :≡ λany.↓
- if any implements JsonProtocol, return Ok#mk(any)

Instances of Ok implement JsonProtocol.

*** Nothing
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 37efa605-0395-405a-b116-bc793f8f90cc
:END:
**** specify

Nothing#mk() : Nothing

nothing :≡ Nothing#mk()

∅ :≡ nothing

*** Just
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: ba431f41-cef6-4074-97cc-d4e136850c22
:END:
**** specify

Just#mk : Any → Just

just :≡ Just#mk

*** Maybe
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 796fd86e-b841-406e-8c17-1163e31fcbd1
:END:
**** specify

Maybe :≡ Nothing | Just(Any)

*** Degraded
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 09eb65d7-a704-4b54-bfdf-d994d4629fc6
:END:
**** specify

Degraded#mk : Any → Degraded :≡ λany.↓
- if any implements JsonProtocol, return Degraded#mk(any)

Instances of Degraded implement JsonProtocol.

*** ServerProtocol
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       44eafef4-4db1-4fff-be14-b346a2f1b01b
:END:
**** specify

Server :≡ Any

Message :≡ Any

Reply :≡ Any

State :≡ Any

ServerProtocol#start : Server Message → None :≡ λserver,data.server#protocol_start data

ServerProtocol#start(server data). After execution, server is ready to receive
messages /i.e./ ServerProtocol#rcv(server msg) has a meaning.

ServerProtocol#rcv : Server Message → Reply × State :≡ λserver,msg.server#protocol_rcv msg

ServerProtocol#state : Server → State :≡ λserver.server#protocol_state()

ServerProtocol#stop : Server → None :≡ λserver.server#protocol_stop()

*** Contract
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: dabad7f3-e4b5-4070-9cb9-c224b7482974
:END:
**** specify

ServerState :≡ Any


NextState :≡ ServerState


Request :≡ Any


Reply :≡ Any


Reply satisfies the JsonProtocol.


Contract :≡ ServerState → Request → (Reply × NextState) → Contract

**** example

contract :≡ λstate.↓
- match state
  - 'idle → λrequest.↓
    - match request
      - "hello" → λreply.↓
        - match reply
          - <"world",'idle> → contract

*** graph_contract
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       d44c84b2-2c30-4463-bb88-3a3ab1cf5ab2
:END:
**** specify

Node :≡ String

Nodes :≡ List(Node)

Edge :≡ Node × Node

Edges :≡ List(Edge)

Sort :≡ ['sort', Nodes, Edges]

client : None Sort → Ok(Sort)

client : Any Any → Error(String)

server : None Sort Ok(Nodes) None → Ok(Ok(Nodes) × None)

server : None Sort Degraded(Nodes × List(Nodes × Edges)) None → Ok(Degraded(Nodes × List(Nodes × Edges)) None)

server : Any Any Any Any → Error(String)

graph_contract :≡ Contract#mk client server

*** Loop
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 389a2c5d-6738-4bf5-9f4b-de9b111faa9b
:END:
**** specify

State :≡ Any

NextState :≡ State

Request :≡ Any

Reply :≡ Any

Init :≡ Any → State

Tx :≡ State Request → Reply NextState

Loop#mk : Init Tx → Loop

loop :≡ Loop#mk init tx

loop#start : Any → Nil :≡ λdata.↓
- state :≡ init(data)
- while true ↓
  - string :≡ read from stdin
  - if string is EOF, break
  - try ↓
    - request :≡ parse string as JSON
    - <reply, next-state> :≡ tx(state request)
    - state :≡ next-state
  - catch e ↓
    - reply :≡ Error(e)
  - write JsonProtocol#string(reply) + '\n' to stdout

**** discuss
***** TODO logging to stderr?

stderr to communicate with the system, i.e., syslog
stdout to communicate with the client?

*** ContractLoop
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 328a7ee3-e5bb-4578-8b56-cbf3164faab9
:END:
**** specify

Server :≡ Anything that satisfies the ServerProtocol ≡: SP.


cl : ContractLoop is a Loop such that each requests from the client and responses
from the server are checked by the contract, assigning blame if not satisfied.


_init_mk : Server → Date → State :≡ λserver.↓
1) SP#start server
2) SP#state server


_tx_mk : Contract Server → (State Request → Reply State) :≡ λcontract,server.↓
1) tx state request :≡
   - match contract(state)
     - ∅ → <Error#mk(…), state>
     - check →
       - match check(request)
         - ∅ → <Error#mk(…), state>
         - check →
           1) response :≡ server#read()
           2) match check(response)
              - ∅ → <Error#mk(…), state>
              - contract → response
2) tx


ContractLoop#mk : Contract Server → ContractLoop :≡ λcontract,server.↓
- Loop#mk _init_mk(server) _tx_mk(contract server)

**** discuss
***** TODO specify match semantics

#+begin_comment
f x :≡
- match x:
    - "match" → "match"

by definition of match, f "do not match" :≡ ∅
#+end_comment

*** DiGraph
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:
**** specify

DiGraph :≡ List(Node) List(Edge)

*** Cycle(g)
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:
**** specify

Cycle : DiGraph → List(Node) :≡ λg.↓
- the set of lst in sublists of nodes in g such that ↓
  - length(lst) ≥ 2
  - ∀ i, <lst[i], lst[i+1]> in edges of g
  - <lst[last], lst[0]> in edges of g

*** DAG
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:
**** specify

DAG :≡ DiGraph without cycles

*** NDAG
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:
**** specify

NDAG :≡ DiGraph with at least one cycle

*** GraphServer
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 3f6c5b98-842c-459f-80c2-389d1acce88f
:END:
**** specify

GraphServer#mk() : GraphServer

server :≡ GraphServer#mk()

server#server_start : Any → GraphServer :≡ λdata.server

server#server_rcv : ['sort', Nodes, Edges] → Any Any :≡ λnodes,edges.↓
- nodes :≡ map Identifier#mk nodes
- edges :≡ map λ<start,end>.<Identifier#mk(start), Identifier#mk(end)> edges
- edges :≡ filter λ<start,end>.start in nodes and end in nodes edges
- g :≡ <nodes, edges>
- digraphs :≡ weakly connected components of g
- digraphs :≡ sort digraphs by ascending number of nodes
- lst :≡ map digraph→dag digraphs where digraph→dag removes cycles
- <dags, rest> :≡ unzip lst
- nodes :≡ concat map topological-sort dags
- rest :≡ filter λ<cycle, edges>.cycle ≠ [] and edges ≠ [] rest
- if rest = [], return <Ok(nodes), Nil>
- else, return <Degraded(<nodes, map λ<cycle, edges>.<cycle, edges> rest>), Nil>

server#server_state() : Nil :≡ λ.Nil

server#server_stop() : Nil :≡ λ.Nil

GraphServer satisfies ServerProtocol and implements graph_contract.

*** DBPath
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:
**** specify

DBPath :≡ Path to a sqlite3 database with table exercise_log of schema Mark#string()
Identifier#string() Time#string()

*** Row
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       ea087479-8cba-49ba-a827-666fab8929e6
:END:
**** specify

Row#mk : Mark Identifier Time → Row

row :≡ Row#mk mark id time

row#mark() : Mark :≡ mark

row#id() : Identifier :≡ id

row#time() : Time :≡ time

*** Db
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       e794f0cb-fa14-4447-9897-cb85683f97f1
:END:
**** specify

Db#mk : Path → Db | ⊥

db :≡ Db#mk path

db#rows() : List(Row)

db#rows : Identifier → List(Row) :≡ λid. filter λrow.row#id() = id db#rows()

*** selector_contract
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       a7d34e35-804b-4533-9441-8661f785c6d1
:END:
**** specify

Ids :≡ List(String)

Select :≡ ['select', DBPath, Threshold, Time, Ids]

client : Nil Select → Ok(Select)

client : Any Any → Error(String)

server : Nil Select Ok(Ids) Nil → Ok(Ok(Ids) Nil)

server : Nil Select Error(String) Nil → Ok(Error(String) Nil)

server : Any Any Any Any → Error(String)

selector_contract :≡ Contract#mk client server

*** SelectorServer
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       92cd74f9-f826-4c5b-912a-9bd83604457e
:END:
**** specify

SelectorServer#mk() : SelectorServer

server :≡ SelectorServer#mk()

server#server_start : Any → SelectorServer :≡ λdata.server

server#server_rcv : DBPath Threshold Time List(String) → Any Any :≡ λpath,threshold,time,ids.↓
- db :≡ Db#mk path
- filter λid.select(db#rows(id) threshold time) ids where select(rows threshold time) is true if no successes or last success time + 2^(successes - 1) days ≤ time

server#server_state() : Nil :≡ λ.Nil

server#server_stop() : Nil :≡ λ.Nil

SelectorServer satisfies ServerProtocol and implements selector_contract.

** Tools
*** locs-and-refs

Implementations and specifications are identified using UUIDs as defined by
[[https://melpa.org/#/locs-and-refs][locs-and-refs]]. An implementation may reference its specification using a reference.

* discuss
** TODO user is informed after cycles are detected
** TODO TODOs are fixed
** TODO Published in MELPA
** TODO ndjson ?
** TODO logger added in Python
